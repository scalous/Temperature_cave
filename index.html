<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Évolution de la Température</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
        }
        #chartContainer {
            width: 100%;
            height: 80vh;
            position: relative;
        }
        #tempChart {
            width: 100%;
            height: 100%;
        }
        #scaleControls {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h2>Évolution de la Température</h2>
    <label for="start-date">Date de début :</label>
    <input type="date" id="start-date">
    <label for="end-date">Date de fin :</label>
    <input type="date" id="end-date">
    <button onclick="fetchData()">Afficher</button>
    <button onclick="autoScaleY()">Auto-échelle Y</button>

    <div id="chartContainer">
        <canvas id="tempChart"></canvas>
    </div>

    <script>
        let tempChart = null;
        let yScaleMin = null;
        let yScaleMax = null;

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            return date.toISOString().slice(0, 19).replace("T", " ") + " UTC";
        }

        async function fetchData() {
            try {
                const startDate = document.getElementById('start-date').value;
                const endDate = document.getElementById('end-date').value;

                if (!startDate || !endDate) {
                    console.error("Veuillez sélectionner des dates valides.");
                    return;
                }

                const apiKeyGarage = "SPJ6Y2W1B009JQTG";
                const apiKeyCave = "0UCS0BOBZ6SXGARL";

                const formattedStartDate = formatDate(startDate);
                const formattedEndDate = formatDate(endDate);

                const garageUrl = `https://api.thingspeak.com/channels/2851323/fields/1.json?api_key=${apiKeyGarage}&start=${formattedStartDate}&end=${formattedEndDate}`;
                const caveUrl = `https://api.thingspeak.com/channels/2865124/fields/1.json?api_key=${apiKeyCave}&start=${formattedStartDate}&end=${formattedEndDate}`;

                console.log("Garage URL:", garageUrl);
                console.log("Cave URL:", caveUrl);

                const [garageResponse, caveResponse] = await Promise.all([
                    fetch(garageUrl),
                    fetch(caveUrl)
                ]);

                if (!garageResponse.ok) {
                    throw new Error(`Garage API Error: ${garageResponse.statusText}`);
                }
                if (!caveResponse.ok) {
                    throw new Error(`Cave API Error: ${caveResponse.statusText}`);
                }

                const garageData = await garageResponse.json();
                const caveData = await caveResponse.json();

                if (!garageData.feeds || !caveData.feeds) {
                    throw new Error("Les données sont absentes ou mal formatées.");
                }

                const formattedGarageData = formatData(garageData.feeds);
                const formattedCaveData = formatData(caveData.feeds);

                plotChart(formattedGarageData, formattedCaveData);
            } catch (error) {
                console.error("Erreur API:", error);
            }
        }

        function formatData(feeds) {
            return feeds.map(feed => ({
                x: new Date(feed.created_at),
                y: parseFloat(feed.field1)
            })).filter(data => !isNaN(data.y));
        }

        function movingAverage(data, windowSize) {
            return data.map((_, i, arr) => {
                const start = Math.max(0, i - windowSize + 1);
                const subset = arr.slice(start, i + 1);
                const avg = subset.reduce((sum, point) => sum + point.y, 0) / subset.length;
                return { x: arr[i].x, y: avg };
            });
        }

        function autoScaleY() {
            if (!tempChart) return;
            const allData = tempChart.data.datasets.flatMap(ds => ds.data);
            const temperatures = allData.map(d => d.y);
            if (temperatures.length > 0) {
                yScaleMin = Math.min(...temperatures) - 2;
                yScaleMax = Math.max(...temperatures) + 2;
                tempChart.options.scales.y.min = yScaleMin;
                tempChart.options.scales.y.max = yScaleMax;
                tempChart.update();
            }
        }

        function plotChart(garageData, caveData) {
            const ctx = document.getElementById('tempChart').getContext('2d');
            if (tempChart) {
                tempChart.destroy();
            }

            const allData = garageData.concat(caveData);
            const temperatures = allData.map(data => data.y);
            yScaleMin = Math.min(...temperatures) - 2;
            yScaleMax = Math.max(...temperatures) + 2;

            tempChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Garage',
                            data: garageData,
                            borderColor: 'red',
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            borderWidth: 1,
                            pointRadius: 2,
                            fill: false
                        },
                        {
                            label: 'Cave',
                            data: caveData,
                            borderColor: 'blue',
                            backgroundColor: 'rgba(0, 0, 255, 0.1)',
                            borderWidth: 1,
                            pointRadius: 2,
                            fill: false
                        },
                        {
                            label: 'Garage (Moyenne mobile)',
                            data: movingAverage(garageData, 5),
                            borderColor: 'darkred',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false
                        },
                        {
                            label: 'Cave (Moyenne mobile)',
                            data: movingAverage(caveData, 5),
                            borderColor: 'darkblue',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                tooltipFormat: 'yyyy-MM-dd HH:mm',
                                displayFormats: {
                                    hour: 'dd MMM HH:mm'
                                }
                            }
                        },
                        y: {
                            min: yScaleMin,
                            max: yScaleMax,
                            title: {
                                display: true,
                                text: 'Température (°C)'
                            }
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: { enabled: true, mode: 'xy' },
                            zoom: { enabled: true, mode: 'xy' }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
